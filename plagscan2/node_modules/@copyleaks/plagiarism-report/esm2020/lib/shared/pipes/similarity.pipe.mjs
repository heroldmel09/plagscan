import { Pipe } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class SimilarityPipe {
    constructor(percentPipe) {
        this.percentPipe = percentPipe;
    }
    /**
     * Works like @angular/common PercentPipe but when value is larger than 0
     * and the result string is 0% , it returns < 1%.
     * See `PercentPipe` for params info.
     */
    transform(value, digitsInfo, locale) {
        let result = this.percentPipe.transform(value, digitsInfo, locale);
        if (value > 0 && parseFloat(result) === 0) {
            result = '< 1%';
        }
        if (value > 1) {
            result = '100%';
        }
        return result;
    }
}
SimilarityPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: SimilarityPipe, deps: [{ token: i1.PercentPipe }], target: i0.ɵɵFactoryTarget.Pipe });
SimilarityPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: SimilarityPipe, name: "similarity" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: SimilarityPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'similarity',
                }]
        }], ctorParameters: function () { return [{ type: i1.PercentPipe }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2ltaWxhcml0eS5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvcGxhZ2lhcmlzbS1yZXBvcnQvc3JjL2xpYi9zaGFyZWQvcGlwZXMvc2ltaWxhcml0eS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDOzs7QUFNcEQsTUFBTSxPQUFPLGNBQWM7SUFDMUIsWUFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7SUFBRyxDQUFDO0lBQ2hEOzs7O09BSUc7SUFDSCxTQUFTLENBQUMsS0FBVSxFQUFFLFVBQW1CLEVBQUUsTUFBZTtRQUN6RCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ25FLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFDLE1BQU0sR0FBRyxNQUFNLENBQUM7U0FDaEI7UUFDRCxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUU7WUFDZCxNQUFNLEdBQUcsTUFBTSxDQUFDO1NBQ2hCO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDZixDQUFDOzsyR0FoQlcsY0FBYzt5R0FBZCxjQUFjOzJGQUFkLGNBQWM7a0JBSDFCLElBQUk7bUJBQUM7b0JBQ0wsSUFBSSxFQUFFLFlBQVk7aUJBQ2xCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGVyY2VudFBpcGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5AUGlwZSh7XG5cdG5hbWU6ICdzaW1pbGFyaXR5Jyxcbn0pXG5leHBvcnQgY2xhc3MgU2ltaWxhcml0eVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3IocHJpdmF0ZSBwZXJjZW50UGlwZTogUGVyY2VudFBpcGUpIHt9XG5cdC8qKlxuXHQgKiBXb3JrcyBsaWtlIEBhbmd1bGFyL2NvbW1vbiBQZXJjZW50UGlwZSBidXQgd2hlbiB2YWx1ZSBpcyBsYXJnZXIgdGhhbiAwXG5cdCAqIGFuZCB0aGUgcmVzdWx0IHN0cmluZyBpcyAwJSAsIGl0IHJldHVybnMgPCAxJS5cblx0ICogU2VlIGBQZXJjZW50UGlwZWAgZm9yIHBhcmFtcyBpbmZvLlxuXHQgKi9cblx0dHJhbnNmb3JtKHZhbHVlOiBhbnksIGRpZ2l0c0luZm8/OiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuXHRcdGxldCByZXN1bHQgPSB0aGlzLnBlcmNlbnRQaXBlLnRyYW5zZm9ybSh2YWx1ZSwgZGlnaXRzSW5mbywgbG9jYWxlKTtcblx0XHRpZiAodmFsdWUgPiAwICYmIHBhcnNlRmxvYXQocmVzdWx0KSA9PT0gMCkge1xuXHRcdFx0cmVzdWx0ID0gJzwgMSUnO1xuXHRcdH1cblx0XHRpZiAodmFsdWUgPiAxKSB7XG5cdFx0XHRyZXN1bHQgPSAnMTAwJSc7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn1cbiJdfQ==
import { Pipe } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/platform-browser";
export class SafePipe {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * A pipe to bypass the security trust for some `content` of some `type`
     * @param content the `content` to declare safe
     * @param type the the `type` of content
     */
    transform(content, type) {
        switch (type) {
            case 'html':
                return this.sanitizer.bypassSecurityTrustHtml(content);
            case 'style':
                return this.sanitizer.bypassSecurityTrustStyle(content);
            case 'script':
                return this.sanitizer.bypassSecurityTrustScript(content);
            case 'url':
                return this.sanitizer.bypassSecurityTrustUrl(content);
            case 'resourceUrl':
                return this.sanitizer.bypassSecurityTrustResourceUrl(content);
            default:
                throw new Error(`Invalid safe type specified: ${type}`);
        }
    }
}
SafePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: SafePipe, deps: [{ token: i1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Pipe });
SafePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: SafePipe, name: "safe" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: SafePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'safe',
                }]
        }], ctorParameters: function () { return [{ type: i1.DomSanitizer }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZS5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvcGxhZ2lhcmlzbS1yZXBvcnQvc3JjL2xpYi9zaGFyZWQvcGlwZXMvc2FmZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDOzs7QUFNcEQsTUFBTSxPQUFPLFFBQVE7SUFDcEIsWUFBc0IsU0FBdUI7UUFBdkIsY0FBUyxHQUFULFNBQVMsQ0FBYztJQUFHLENBQUM7SUFDakQ7Ozs7T0FJRztJQUNJLFNBQVMsQ0FBQyxPQUFZLEVBQUUsSUFBWTtRQUMxQyxRQUFRLElBQUksRUFBRTtZQUNiLEtBQUssTUFBTTtnQkFDVixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDeEQsS0FBSyxPQUFPO2dCQUNYLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyx3QkFBd0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN6RCxLQUFLLFFBQVE7Z0JBQ1osT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzFELEtBQUssS0FBSztnQkFDVCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDdkQsS0FBSyxhQUFhO2dCQUNqQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsOEJBQThCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDL0Q7Z0JBQ0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUN6RDtJQUNGLENBQUM7O3FHQXRCVyxRQUFRO21HQUFSLFFBQVE7MkZBQVIsUUFBUTtrQkFIcEIsSUFBSTttQkFBQztvQkFDTCxJQUFJLEVBQUUsTUFBTTtpQkFDWiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERvbVNhbml0aXplciwgU2FmZUh0bWwsIFNhZmVTdHlsZSwgU2FmZVNjcmlwdCwgU2FmZVVybCwgU2FmZVJlc291cmNlVXJsIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5cbkBQaXBlKHtcblx0bmFtZTogJ3NhZmUnLFxufSlcbmV4cG9ydCBjbGFzcyBTYWZlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgc2FuaXRpemVyOiBEb21TYW5pdGl6ZXIpIHt9XG5cdC8qKlxuXHQgKiBBIHBpcGUgdG8gYnlwYXNzIHRoZSBzZWN1cml0eSB0cnVzdCBmb3Igc29tZSBgY29udGVudGAgb2Ygc29tZSBgdHlwZWBcblx0ICogQHBhcmFtIGNvbnRlbnQgdGhlIGBjb250ZW50YCB0byBkZWNsYXJlIHNhZmVcblx0ICogQHBhcmFtIHR5cGUgdGhlIHRoZSBgdHlwZWAgb2YgY29udGVudFxuXHQgKi9cblx0cHVibGljIHRyYW5zZm9ybShjb250ZW50OiBhbnksIHR5cGU6IHN0cmluZyk6IFNhZmVIdG1sIHwgU2FmZVN0eWxlIHwgU2FmZVNjcmlwdCB8IFNhZmVVcmwgfCBTYWZlUmVzb3VyY2VVcmwge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnaHRtbCc6XG5cdFx0XHRcdHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0SHRtbChjb250ZW50KTtcblx0XHRcdGNhc2UgJ3N0eWxlJzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZShjb250ZW50KTtcblx0XHRcdGNhc2UgJ3NjcmlwdCc6XG5cdFx0XHRcdHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0U2NyaXB0KGNvbnRlbnQpO1xuXHRcdFx0Y2FzZSAndXJsJzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RVcmwoY29udGVudCk7XG5cdFx0XHRjYXNlICdyZXNvdXJjZVVybCc6XG5cdFx0XHRcdHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0UmVzb3VyY2VVcmwoY29udGVudCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2FmZSB0eXBlIHNwZWNpZmllZDogJHt0eXBlfWApO1xuXHRcdH1cblx0fVxufVxuIl19
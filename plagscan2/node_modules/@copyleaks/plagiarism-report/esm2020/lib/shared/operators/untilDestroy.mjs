import { Observable } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
/** create a symbol identify the observable I add to
 * the component so it doesn't conflict with anything.
 * I need this so I'm able to add the desired behaviour to the component.
 */
export const destroy$ = Symbol('destroy$');
/**
 * decorate `component`'s ngOnDestroy method and complete it before destroy
 * @internal
 */
export const addDestroyObservableToComponent = (component) => {
    component[destroy$] = new Observable(observer => {
        // keep track of the original destroy function,
        // the user might do something in there
        const orignalDestroy = component.ngOnDestroy;
        if (orignalDestroy == null) {
            // Angular does not support dynamic added destroy methods
            // so make sure there is one.
            throw new Error('untilDestroy operator needs the component to have an ngOnDestroy method');
        }
        // replace the ngOndestroy
        component.ngOnDestroy = () => {
            // fire off the destroy observable
            observer.next();
            // complete the observable
            observer.complete();
            // and at last, call the original destroy
            orignalDestroy.call(component);
        };
        // return cleanup function.
        return (_) => (component[destroy$] = undefined);
    });
};
/**
 * An operator that takes until destroy it takes a components this a parameter
 * returns a pipeable RxJS operator.
 */
export const untilDestroy = (component) => {
    if (component[destroy$] === undefined) {
        // only hookup each component once.
        addDestroyObservableToComponent(component);
    }
    // pipe in the takeUntil destroy$ and return the source unaltered
    return takeUntil(component[destroy$]);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW50aWxEZXN0cm95LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvcGxhZ2lhcmlzbS1yZXBvcnQvc3JjL2xpYi9zaGFyZWQvb3BlcmF0b3JzL3VudGlsRGVzdHJveS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQTRCLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM1RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0M7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUUzQzs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSwrQkFBK0IsR0FBRyxDQUFDLFNBQWMsRUFBRSxFQUFFO0lBQ2pFLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLFVBQVUsQ0FBTyxRQUFRLENBQUMsRUFBRTtRQUNyRCwrQ0FBK0M7UUFDL0MsdUNBQXVDO1FBQ3ZDLE1BQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxXQUFXLENBQUM7UUFDN0MsSUFBSSxjQUFjLElBQUksSUFBSSxFQUFFO1lBQzNCLHlEQUF5RDtZQUN6RCw2QkFBNkI7WUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyx5RUFBeUUsQ0FBQyxDQUFDO1NBQzNGO1FBQ0QsMEJBQTBCO1FBQzFCLFNBQVMsQ0FBQyxXQUFXLEdBQUcsR0FBRyxFQUFFO1lBQzVCLGtDQUFrQztZQUNsQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDaEIsMEJBQTBCO1lBQzFCLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNwQix5Q0FBeUM7WUFDekMsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNoQyxDQUFDLENBQUM7UUFDRiwyQkFBMkI7UUFDM0IsT0FBTyxDQUFDLENBQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7SUFDdEQsQ0FBQyxDQUFDLENBQUM7QUFDSixDQUFDLENBQUM7QUFFRjs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUcsQ0FBSSxTQUFjLEVBQStCLEVBQUU7SUFDOUUsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssU0FBUyxFQUFFO1FBQ3RDLG1DQUFtQztRQUNuQywrQkFBK0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUMzQztJQUNELGlFQUFpRTtJQUNqRSxPQUFPLFNBQVMsQ0FBSSxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUMxQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqIGNyZWF0ZSBhIHN5bWJvbCBpZGVudGlmeSB0aGUgb2JzZXJ2YWJsZSBJIGFkZCB0b1xuICogdGhlIGNvbXBvbmVudCBzbyBpdCBkb2Vzbid0IGNvbmZsaWN0IHdpdGggYW55dGhpbmcuXG4gKiBJIG5lZWQgdGhpcyBzbyBJJ20gYWJsZSB0byBhZGQgdGhlIGRlc2lyZWQgYmVoYXZpb3VyIHRvIHRoZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBkZXN0cm95JCA9IFN5bWJvbCgnZGVzdHJveSQnKTtcblxuLyoqXG4gKiBkZWNvcmF0ZSBgY29tcG9uZW50YCdzIG5nT25EZXN0cm95IG1ldGhvZCBhbmQgY29tcGxldGUgaXQgYmVmb3JlIGRlc3Ryb3lcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgYWRkRGVzdHJveU9ic2VydmFibGVUb0NvbXBvbmVudCA9IChjb21wb25lbnQ6IGFueSkgPT4ge1xuXHRjb21wb25lbnRbZGVzdHJveSRdID0gbmV3IE9ic2VydmFibGU8dm9pZD4ob2JzZXJ2ZXIgPT4ge1xuXHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIG9yaWdpbmFsIGRlc3Ryb3kgZnVuY3Rpb24sXG5cdFx0Ly8gdGhlIHVzZXIgbWlnaHQgZG8gc29tZXRoaW5nIGluIHRoZXJlXG5cdFx0Y29uc3Qgb3JpZ25hbERlc3Ryb3kgPSBjb21wb25lbnQubmdPbkRlc3Ryb3k7XG5cdFx0aWYgKG9yaWduYWxEZXN0cm95ID09IG51bGwpIHtcblx0XHRcdC8vIEFuZ3VsYXIgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGFkZGVkIGRlc3Ryb3kgbWV0aG9kc1xuXHRcdFx0Ly8gc28gbWFrZSBzdXJlIHRoZXJlIGlzIG9uZS5cblx0XHRcdHRocm93IG5ldyBFcnJvcigndW50aWxEZXN0cm95IG9wZXJhdG9yIG5lZWRzIHRoZSBjb21wb25lbnQgdG8gaGF2ZSBhbiBuZ09uRGVzdHJveSBtZXRob2QnKTtcblx0XHR9XG5cdFx0Ly8gcmVwbGFjZSB0aGUgbmdPbmRlc3Ryb3lcblx0XHRjb21wb25lbnQubmdPbkRlc3Ryb3kgPSAoKSA9PiB7XG5cdFx0XHQvLyBmaXJlIG9mZiB0aGUgZGVzdHJveSBvYnNlcnZhYmxlXG5cdFx0XHRvYnNlcnZlci5uZXh0KCk7XG5cdFx0XHQvLyBjb21wbGV0ZSB0aGUgb2JzZXJ2YWJsZVxuXHRcdFx0b2JzZXJ2ZXIuY29tcGxldGUoKTtcblx0XHRcdC8vIGFuZCBhdCBsYXN0LCBjYWxsIHRoZSBvcmlnaW5hbCBkZXN0cm95XG5cdFx0XHRvcmlnbmFsRGVzdHJveS5jYWxsKGNvbXBvbmVudCk7XG5cdFx0fTtcblx0XHQvLyByZXR1cm4gY2xlYW51cCBmdW5jdGlvbi5cblx0XHRyZXR1cm4gKF86IGFueSkgPT4gKGNvbXBvbmVudFtkZXN0cm95JF0gPSB1bmRlZmluZWQpO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQW4gb3BlcmF0b3IgdGhhdCB0YWtlcyB1bnRpbCBkZXN0cm95IGl0IHRha2VzIGEgY29tcG9uZW50cyB0aGlzIGEgcGFyYW1ldGVyXG4gKiByZXR1cm5zIGEgcGlwZWFibGUgUnhKUyBvcGVyYXRvci5cbiAqL1xuZXhwb3J0IGNvbnN0IHVudGlsRGVzdHJveSA9IDxUPihjb21wb25lbnQ6IGFueSk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPiA9PiB7XG5cdGlmIChjb21wb25lbnRbZGVzdHJveSRdID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBvbmx5IGhvb2t1cCBlYWNoIGNvbXBvbmVudCBvbmNlLlxuXHRcdGFkZERlc3Ryb3lPYnNlcnZhYmxlVG9Db21wb25lbnQoY29tcG9uZW50KTtcblx0fVxuXHQvLyBwaXBlIGluIHRoZSB0YWtlVW50aWwgZGVzdHJveSQgYW5kIHJldHVybiB0aGUgc291cmNlIHVuYWx0ZXJlZFxuXHRyZXR1cm4gdGFrZVVudGlsPFQ+KGNvbXBvbmVudFtkZXN0cm95JF0pO1xufTtcbiJdfQ==